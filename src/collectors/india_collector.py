# -*- coding: utf-8 -*-
"""India Collector.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mzhYhIsSvui599ZREf4CFq7k5m3D4N3K
"""

import requests
from bs4 import BeautifulSoup
import pandas as pd
import re
import time
from concurrent.futures import ThreadPoolExecutor, as_completed
import numpy as np

def fetch_meidb_data(session, url, data, headers):
    """
    Выполняет запрос к MEIDB и возвращает данные
    """
    try:
        response = session.post(url, data=data, headers=headers, timeout=30)
        response.raise_for_status()

        # Парсим HTML с результатами
        soup = BeautifulSoup(response.content, 'html.parser')

        # Ищем таблицу с данными
        table = soup.find('table', {'id': 'example1'})

        if not table:
            print(f"Таблица не найдена для {url}")
            return pd.DataFrame()

        # Извлекаем заголовки
        headers_list = []
        for th in table.find_all('th'):
            headers_list.append(th.get_text(strip=True).replace('\xa0', ' '))

        # Извлекаем данные
        rows_data = []
        for tr in table.find_all('tr')[1:]:  # Пропускаем строку заголовков
            cells = tr.find_all('td')
            if cells:
                row_data = [cell.get_text(strip=True).replace('\xa0', ' ') for cell in cells]
                rows_data.append(row_data)

        # Создаем DataFrame
        df = pd.DataFrame(rows_data, columns=headers_list)
        return df
    except Exception as e:
        print(f"Ошибка при выполнении запроса: {e}")
        return pd.DataFrame()

def process_trade_data(df, flow_type, data_type):
    """
    Обрабатывает данные торговли и возвращает обработанный DataFrame
    """
    if df.empty:
        return pd.DataFrame()

    # Находим нужные столбцы

    hs_col = next((col for col in df.columns if 'HSCode' in col or 'HS Code' in col), None)
    commodity_col = next((col for col in df.columns if 'Commodity' in col), None)

    # Находим столбец со значениями
    value_col = None
    value_cols = []
    for col in df.columns:
        if re.search(r'\w{3}-\d{4}', col) or re.search(r'\([RF]\)', col):
            value_cols.append(col)

    if not value_cols:
        print("Не удалось найти столбец с данными о стоимости")
        return pd.DataFrame()

    value_col = value_cols[1] if len(value_cols) > 1 else value_cols[0]

    if not all([hs_col, commodity_col, value_col]):
        print("Не удалось найти все необходимые столбцы")
        return pd.DataFrame()

    # Создаем базовый DataFrame с кодом и названием товара
    result_df = df[[hs_col, commodity_col]].copy()
    result_df.columns = ['HSCode', 'Commodity']

    # Обрабатываем значения в зависимости от типа данных
    if data_type == 'quantity':
        unit_col = next((col for col in df.columns if 'Unit' in col or 'UOM' in col), None)

        # Преобразуем в числовой формат, заменяя ошибки на NaN
        quantity_values = pd.to_numeric(df[value_col].str.replace(',', ''), errors='coerce')

        # ЗАМЕНЯЕМ ТОЛЬКО ДЛЯ QUANTITY: 0 на NaN
        quantity_values = quantity_values.replace(0, np.nan)

        result_df['Quantity'] = quantity_values

        if unit_col:
            result_df['Unit'] = df[unit_col]
            # Если количество NaN, то и единица измерения тоже должна быть NaN
            result_df.loc[result_df['Quantity'].isna(), 'Unit'] = np.nan
        else:
            result_df['Unit'] = 'Unknown'
            result_df.loc[result_df['Quantity'].isna(), 'Unit'] = np.nan
    elif data_type == 'usd':
        # ДЛЯ ДЕНЕЖНЫХ ДАННЫХ ОСТАВЛЯЕМ 0 КАК ЕСТЬ
        usd_values = pd.to_numeric(df[value_col].str.replace(',', ''), errors='coerce')
        result_df['USD'] = usd_values
    elif data_type == 'inr':
        # ДЛЯ ДЕНЕЖНЫХ ДАННЫХ ОСТАВЛЯЕМ 0 КАК ЕСТЬ
        inr_values = pd.to_numeric(df[value_col].str.replace(',', ''), errors='coerce')
        result_df['INR'] = inr_values

    result_df['Flow'] = flow_type
    return result_df

def get_trade_data_for_flow(year, month, country_code, flow_type):
    """
    Получает все данные для указанного типа потока (экспорт/импорт)
    """
    # Определяем параметры в зависимости от типа торговли
    if flow_type == 'Ex':
        url = 'https://tradestat.commerce.gov.in/meidb/country_wise_all_commodities_export'
        month_field = 'cwcexddMonth'
        year_field = 'cwcexddYear'
        country_field = 'cwcexallcount'
        commodity_level_field = 'cwcexddCommodityLevel'
        report_val_field = 'cwcexddReportVal'
        report_year_field = 'cwcexddReportYear'
        referer = 'https://tradestat.commerce.gov.in/meidb/country_wise_all_commodities_export'
    else:
        url = 'https://tradestat.commerce.gov.in/meidb/country_wise_all_commodities_import'
        month_field = 'cwcimMonth'
        year_field = 'cwcimYear'
        country_field = 'cwcimallcount'
        commodity_level_field = 'cwcimCommodityLevel'
        report_val_field = 'cwcimReportVal'
        report_year_field = 'cwcimReportYear'
        referer = 'https://tradestat.commerce.gov.in/meidb/country_wise_all_commodities_import'

    # Создаем сессию для сохранения куки
    session = requests.Session()

    # Первый GET-запрос для получения CSRF-токена
    try:
        response_get = session.get(url, timeout=30)
        response_get.raise_for_status()

        # Парсим HTML для извлечения CSRF-токена
        soup = BeautifulSoup(response_get.content, 'html.parser')
        token_input = soup.find('input', {'name': '_token'})
        csrf_token = token_input.get('value') if token_input else None

        if not csrf_token:
            print(f"CSRF-токен не найден для {flow_type}")
            return pd.DataFrame()
    except Exception as e:
        print(f"Ошибка при получении CSRF-токена для {flow_type}: {e}")
        return pd.DataFrame()

    # Заголовки для имитации браузера
    headers = {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
        'Accept-Language': 'en-US,en;q=0.5',
        'Referer': referer,
    }

    # Создаем список для хранения результатов
    results = []

    # Выполняем запросы для всех трех типов данных
    for data_type, report_val in [('usd', 1), ('inr', 3), ('quantity', 2)]:
        # Подготавливаем данные для POST-запроса
        data = {
            month_field: month,
            year_field: year,
            country_field: country_code,
            commodity_level_field: 8,
            report_val_field: report_val,
            report_year_field: 2,
            '_token': csrf_token
        }

        print(f"Получение данных {flow_type} для типа {data_type}...")
        df = fetch_meidb_data(session, url, data, headers)

        if not df.empty:
            processed_df = process_trade_data(df, flow_type, data_type)
            if not processed_df.empty:
                results.append(processed_df)

        time.sleep(1)  # Пауза между запросами

    # Объединяем все результаты для этого потока
    if results:
        # Начинаем с первого DataFrame
        result_df = results[0]

        # Последовательно объединяем с остальными
        for i in range(1, len(results)):
            result_df = result_df.merge(
                results[i],
                on=['HSCode', 'Commodity', 'Flow'],
                how='outer'
            )

        # Добавляем информацию о годе и месяце
        result_df['Year'] = year
        result_df['Month'] = month

        return result_df

    return pd.DataFrame()

def get_all_trade_data(year, month, country_code=344):
    """
    Получает данные и для экспорта, и для импорта параллельно
    """
    results = {}


    with ThreadPoolExecutor(max_workers=2) as executor:

        future_to_flow = {
            executor.submit(get_trade_data_for_flow, year, month, country_code, 'Ex'): 'Ex',
            executor.submit(get_trade_data_for_flow, year, month, country_code, 'Im'): 'Im'
        }


        for future in as_completed(future_to_flow):
            flow_type = future_to_flow[future]
            try:
                results[flow_type] = future.result()
            except Exception as e:
                print(f"Ошибка при получении данных для {flow_type}: {e}")
                results[flow_type] = pd.DataFrame()


    if not results['Ex'].empty and not results['Im'].empty:
        combined_df = pd.concat([results['Ex'], results['Im']], ignore_index=True)
    elif not results['Ex'].empty:
        combined_df = results['Ex']
    elif not results['Im'].empty:
        combined_df = results['Im']
    else:
        combined_df = pd.DataFrame()

    combined_df['USD'] = 1000 * combined_df['USD'] # converting to thousand USD (prior - mln USD)

    combined_df.Flow = combined_df.Flow.apply(lambda x: 'ИМ' if x == 'Ex' else 'ЭК')

    rename_dict = {'HSCode': 'TNVED', 'USD': 'STOIM', 'Flow': 'NAPR', 'INR': 'STOIM_NAC_VAL',
                   'Quantity': 'KOL', 'Unit': 'EDIZM'}

    combined_df.rename(columns = rename_dict, inplace = True)

    combined_df.EDIZM = combined_df.EDIZM.apply(lambda x: 'KGS' if x == 'KG' else x)

    combined_df['NETTO'] = np.where(combined_df.EDIZM == 'KGS', combined_df.KOL, np.nan)

    combined_df['TNVED2'] = combined_df['TNVED'].apply(lambda x: x[0:2])

    combined_df['TNVED4'] = combined_df['TNVED'].apply(lambda x: x[0:4])

    combined_df['TNVED6'] = combined_df['TNVED'].apply(lambda x: x[0:6])

    combined_df['PERIOD'] = pd.to_datetime(combined_df["Year"].astype(str) + "-" + combined_df["Month"].astype(str).str.zfill(2) + "-01")

    combined_df['STRANA'] = 'IN'

    return combined_df

from pathlib import Path
import os

def save_india_data(df, year, month, output_dir=None):
    """
    Сохраняет все данные Индии (импорт и экспорт вместе)
    в формате: data_raw/india/india_data_YYYY_MM.csv
    """
    if df.empty:
        print("Нет данных для сохранения.")
        return

    try:

        project_root = Path(__file__).resolve().parent.parent
    except NameError:

        project_root = Path(os.getcwd())

    if output_dir is None:
        output_dir = project_root / 'data_raw' / 'india_new'

    output_dir.mkdir(parents=True, exist_ok=True)


    month_str = str(month).zfill(2)
    filename = f"india_data_{year}_{month_str}.csv"
    save_path = output_dir / filename


    df.to_csv(save_path, index=False, encoding='utf-8-sig')

    print(f"✅ Данные сохранены: {save_path}")

combined_data.describe()

import itertools
last = (2025,8)
a = [x for x in range(2018, last[0]+1)]
b = [x for x in range(1,13)]
all_dates = sorted(set([x for x in list(itertools.product(a, b)) if (x[0]<=last[0]-1) or (x[0]==last[0] and x[1]<=last[1])]))

for (i, j) in all_dates:
  if __name__ == "__main__":
    print("Начало парсинга данных...")


    combined_data = get_all_trade_data(i, j, 344)

    if not combined_data.empty:
        print(f"Данные успешно получены: {combined_data['Year'].iloc[0]}_{combined_data['Month'].iloc[0]:02d}")
        print(combined_data.head())


        filename = f"india_{combined_data['Year'].iloc[0]}_{combined_data['Month'].iloc[0]:02d}.csv"
        combined_data.to_csv(filename, index=False, encoding='utf-8')
        save_india_data(combined_data, i, j)
        print(f"\nДанные сохранены в файл '{filename}'")
    else:
        print("Не удалось получить данные")